const fs = require('fs').promises;
const path = require('path');
const Jimp = require('jimp');
const Country = require('../models/country');

class ImageService {
  static async generateSummaryImage() {
    try {
      // Get top 5 countries by GDP
      const topCountries = await Country.getTopCountriesByGDP(5);
      const systemStatus = await Country.getSystemStatus();
      
      // Create a blank image with Jimp
      const width = 800;
      const height = 600;
      const image = new Jimp(width, height, '#f8f9fa');
      
      // Load a font (Jimp provides built-in fonts)
      const font32 = await Jimp.loadFont(Jimp.FONT_SANS_32_BLACK);
      const font24 = await Jimp.loadFont(Jimp.FONT_SANS_24_BLACK);
      const font20 = await Jimp.loadFont(Jimp.FONT_SANS_20_BLACK);
      const font18 = await Jimp.loadFont(Jimp.FONT_SANS_18_BLACK);
      const font14 = await Jimp.loadFont(Jimp.FONT_SANS_14_GRAY);
      
      // Add header
      const headerText = 'Country Currency Exchange Summary';
      const headerX = (width - Jimp.measureText(font32, headerText)) / 2;
      image.print(font32, headerX, 30, headerText);
      
      // Add total countries count
      const totalText = `Total Countries: ${systemStatus.total_countries}`;
      const totalX = (width - Jimp.measureText(font20, totalText)) / 2;
      image.print(font20, totalX, 80, totalText);
      
      // Add last refresh timestamp
      if (systemStatus.last_refreshed_at) {
        const refreshDate = new Date(systemStatus.last_refreshed_at).toLocaleString();
        const refreshText = `Last Refresh: ${refreshDate}`;
        const refreshX = (width - Jimp.measureText(font20, refreshText)) / 2;
        image.print(font20, refreshX, 110, refreshText);
      }
      
      // Add top countries section
      const topText = 'Top 5 Countries by Estimated GDP';
      const topX = (width - Jimp.measureText(font24, topText)) / 2;
      image.print(font24, topX, 160, topText);
      
      // Display top countries
      let yPos = 210;
      const leftMargin = 100;
      const nameX = 140;
      const gdpX = 400;
      const currencyX = 620;
      
      for (let i = 0; i < topCountries.length; i++) {
        const country = topCountries[i];
        const rank = i + 1;
        
        // Rank (in blue)
        const rankText = `${rank}.`;
        image.print(font18, leftMargin, yPos, { text: rankText, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP });
        
        // Country name
        image.print(font18, nameX, yPos, { text: country.name, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP });
        
        // GDP (formatted)
        const gdpFormatted = country.estimated_gdp 
          ? `$${country.estimated_gdp.toLocaleString('en-US', { maximumFractionDigits: 2 })}`
          : 'N/A';
        image.print(font18, gdpX, yPos, { text: gdpFormatted, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP });
        
        // Currency code (in gray)
        if (country.currency_code) {
          const currencyText = `(${country.currency_code})`;
          image.print(font18, currencyX, yPos, { text: currencyText, alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP });
        }
        
        yPos += 35;
      }
      
      // Add footer
      const footerText = 'Generated by Currency Exchange API';
      const footerX = (width - Jimp.measureText(font14, footerText)) / 2;
      image.print(font14, footerX, height - 40, footerText);
      
      // Ensure cache directory exists
      const cacheDir = process.env.IMAGE_PATH || './cache';
      await fs.mkdir(cacheDir, { recursive: true });
      
      // Save image
      const imagePath = path.join(cacheDir, process.env.IMAGE_NAME || 'summary.png');
      await image.writeAsync(imagePath);
      
      console.log(`Summary image generated at: ${imagePath}`);
      return imagePath;
    } catch (error) {
      console.error('Error generating summary image:', error);
      throw new Error(`Failed to generate summary image: ${error.message}`);
    }
  }
  
  static async imageExists() {
    try {
      const cacheDir = process.env.IMAGE_PATH || './cache';
      const imagePath = path.join(cacheDir, process.env.IMAGE_NAME || 'summary.png');
      await fs.access(imagePath);
      return imagePath;
    } catch (error) {
      return null;
    }
  }
}

module.exports = ImageService;